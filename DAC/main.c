#include <stdint.h>
#include "tm4c123gh6pm.h"
#include <stdio.h>
#include <math.h>

// Color    LED(s) PortF
// dark     ---    0
// red      R--    0x02
// blue     --B    0x04
// green    -G-    0x08
// yellow   RG-    0x0A
// sky blue -GB    0x0C
// white    RGB    0x0E
// pink     R-B    0x06



/*
float Output[256] = { 
1.65
,1.690651791
,1.731278903
,1.77185667
,1.812360459
,1.85276568
,1.893047802
,1.933182371
,1.973145021
,2.01291149
,2.052457638
,2.091759455
,2.130793082
,2.169534822
,2.207961153
,2.246048749
,2.283774486
,2.321115461
,2.358049004
,2.394552694
,2.430604369
,2.466182142
,2.501264413
,2.535829886
,2.569857575
,2.603326822
,2.636217308
,2.668509065
,2.70018249
,2.731218353
,2.761597812
,2.791302425
,2.820314158
,2.848615397
,2.876188962
,2.903018112
,2.929086561
,2.95437848
,2.978878517
,3.002571797
,3.025443936
,3.047481048
,3.068669755
,3.088997193
,3.108451022
,3.127019431
,3.144691147
,3.161455442
,3.177302139
,3.192221616
,3.206204817
,3.219243252
,3.231329006
,3.242454741
,3.252613703
,3.261799724
,3.270007229
,3.277231233
,3.283467352
,3.288711799
,3.292961391
,3.296213547
,3.298466294
,3.299718263
,3.299968695
,3.299217438
,3.297464947
,3.294712286
,3.290961127
,3.286213748
,3.280473029
,3.273742457
,3.266026117
,3.257328693
,3.247655468
,3.237012311
,3.225405686
,3.212842638
,3.199330795
,3.184878359
,3.169494105
,3.153187371
,3.135968059
,3.117846621
,3.098834059
,3.078941916
,3.058182268
,3.036567718
,3.014111388
,2.990826912
,2.966728425
,2.941830557
,2.916148424
,2.889697618
,2.862494196
,2.834554673
,2.805896012
,2.776535611
,2.746491295
,2.715781303
,2.68442428
,2.652439261
,2.619845666
,2.586663282
,2.552912252
,2.518613069
,2.483786554
,2.44845385
,2.412636408
,2.376355972
,2.339634569
,2.302494491
,2.264958287
,2.227048743
,2.188788876
,2.150201912
,2.111311278
,2.072140583
,2.032713608
,1.99305429
,1.953186704
,1.913135055
,1.872923658
,1.832576925
,1.79211935
,1.751575495
,1.710969974
,1.670327438
,1.629672562
,1.589030026
,1.548424505
,1.50788065
,1.467423075
,1.427076342
,1.386864945
,1.346813296
,1.30694571
,1.267286392
,1.227859417
,1.188688722
,1.149798088
,1.111211124
,1.072951257
,1.035041713
,0.9975055087
,0.9603654309
,0.9236440276
,0.8873635922
,0.8515461502
,0.8162134465
,0.7813869313
,0.7470877476
,0.7133367184
,0.6801543337
,0.6475607385
,0.6155757203
,0.5842186969
,0.5535087051
,0.5234643889
,0.494103988
,0.4654453269
,0.4375058044
,0.4103023822
,0.3838515756
,0.3581694427
,0.333271575
,0.3091730879
,0.2858886115
,0.2634322818
,0.2418177318
,0.2210580838
,0.2011659407
,0.182153379
,0.1640319412
,0.1468126287
,0.1305058954
,0.1151216409
,0.100669205
,0.08715736167
,0.07459431394
,0.06298768876
,0.05234453249
,0.04267130653
,0.03397388346
,0.02625754345
,0.01952697107
,0.01378625241
,0.009038872642
,0.005287713887
,0.002535053454
,0.0007825624729
,0.0000313048746
,0.0002817367442
,0.001533706046
,0.003786452713
,0.007038609113
,0.01128820087
,0.01653264809
,0.02276876687
,0.02999277129
,0.0382002757
,0.04738629734
,0.05754525942
,0.06867099447
,0.08075674811
,0.09379518312
,0.1077783839
,0.1226978614
,0.1385445579
,0.155308853
,0.1729805693
,0.1915489781
,0.2110028069
,0.2313302451
,0.2525189521
,0.2745560644
,0.2974282032
,0.321121483
,0.3456215197
,0.3709134394
,0.3969818875
,0.423811038
,0.4513846029
,0.4796858425
,0.5086975751
,0.538402188
,0.5687816475
,0.5998175104
,0.6314909349
,0.6637826922
,0.6966731782
,0.7301424251
,0.7641701139
,0.7987355865
,0.8338178584
,0.8693956312
,0.9054473059
,0.9419509955
,0.9788845389
,1.016225514
,1.053951251
,1.092038847
,1.130465178
,1.169206918
,1.208240545
,1.247542362
,1.28708851
,1.326854979
,1.366817629
,1.406952198
,1.44723432
,1.487639541
,1.52814333
,1.568721097
,1.609348209
,1.65
};

*/
int i = 0, sine_check = 0;
float  increment = (2.0*3.1415926535)/255.0;
float Output[256];
void Sine_Init(void){
	for(i = 0; i < 256; i = i + 1){
		Output[i] = (1.65 * sin(i*increment)) + 1.65;
		}
}

void sine_wave(void){
	
	sine_check = (sine_check == 255)? 0: sine_check + 1;
	GPIO_PORTB_DATA_R  = floor((((Output[sine_check])*255.0)/3.3));
	
}


int square_check = 0, UPHDL = 0, triangle_check = 0;

void sawtooth(void){
	
	GPIO_PORTB_DATA_R =(GPIO_PORTB_DATA_R == 255)? 0: GPIO_PORTB_DATA_R + 1;
	//GPIO_PORTB_DATA_R |= 0xFF;
}

void squarewave(void){
	square_check += 1;
	square_check = (square_check > 255)? 0: square_check;
	GPIO_PORTB_DATA_R =(square_check < 128)? 0x00: 0xFF;	
}



void trianglewave(void){
	UPHDL = ((GPIO_PORTB_DATA_R == 0) || (GPIO_PORTB_DATA_R == 254))?  UPHDL^1: UPHDL;
	GPIO_PORTB_DATA_R =(UPHDL)? GPIO_PORTB_DATA_R + 2: GPIO_PORTB_DATA_R - 2;
	}



void PortB_Init(void){volatile unsigned long delay;

	SYSCTL_RCGC2_R |= 0x02;//activating port b clock
	delay = SYSCTL_RCGC2_R;//delay
	GPIO_PORTB_CR_R |= 0xFF;//allows changes to all bits of port B
	GPIO_PORTB_AMSEL_R &= ~0xFF;////Disables Analog functionality on all of port b
	GPIO_PORTB_PCTL_R &= 0x00000000;//All pins are set up for GPIO
	GPIO_PORTB_DIR_R |= 0xFF;//All pins are output
	GPIO_PORTB_AFSEL_R &= ~0xFF;//All pins are not using alternate function
	GPIO_PORTB_PUR_R |= 0xFF;//
	GPIO_PORTB_DEN_R |= 0xFF;//All pins are digitaly enabled
	//initializing port b
	GPIO_PORTB_DATA_R &= ~0xFF;//Clears all bit on Port B
	
}

void Button_Init(void){volatile unsigned long delay;//delay
	SYSCTL_RCGC2_R |= 0x20;//clock to portF
	delay = SYSCTL_RCGC2_R;//delay
	GPIO_PORTF_LOCK_R |= 0x4C4F434B;
	GPIO_PORTF_CR_R |= 0x11;//allows changes to PF0 and PF4
	GPIO_PORTF_AMSEL_R &= ~0x11;//disables analog functionality to PF0 and PF4
	GPIO_PORTF_PCTL_R &= ~0x000F000F;//GPIO Functionality to PF0 and PF4
	GPIO_PORTF_DIR_R |= ~0x11;
	GPIO_PORTF_AFSEL_R &= ~0x11;//disables alternate functionalit to PF0 and PF4
	GPIO_PORTF_PUR_R |= 0x11;
	GPIO_PORTF_DEN_R |= 0x11;
	
	GPIO_PORTF_IS_R &= ~0x11;//PF0 and PF4 edge triggerd
	GPIO_PORTF_IBE_R &= ~0x11;//Not triggered on both edges
	GPIO_PORTF_IEV_R &= ~0x11;//faling edge triggered
	GPIO_PORTF_ICR_R = 0x11;//clear flags
	GPIO_PORTF_IM_R = 0x11;//arm interrupt
	
	NVIC_PRI7_R = (NVIC_PRI7_R & ~0x00E00000)|0x00400000;
	NVIC_EN0_R = 0x40000000;
}

void LED_Init(void){volatile unsigned long delay;
	SYSCTL_RCGC2_R |= 0x20;//activate clock for port F
	delay = SYSCTL_RCGC2_R;//delay
	GPIO_PORTF_LOCK_R |= 0x4C4F434B;//unlock
	GPIO_PORTF_CR_R |= 0x0E;//allow changes
	GPIO_PORTF_AMSEL_R &= ~0x0E;//disable analog functionality
	GPIO_PORTF_PCTL_R &= ~0x0000FFF0;//configure to GPIO
	GPIO_PORTF_DIR_R |= 0x0E;//output
	GPIO_PORTF_AFSEL_R &= ~0x0E;//disable alt function
	GPIO_PORTF_PUR_R |= 0x0E;//
	GPIO_PORTF_DEN_R |= 0x0E;//enable digitle I/O
	
	GPIO_PORTF_DATA_R |= 0x02;//make red initially
	
}

void GPIOPortF_Handler(void){
	

	if(GPIO_PORTF_RIS_R&0x01){//if PF0    SW2	
		GPIO_PORTF_ICR_R = 0x01;
		////////////////
		
	}
	
	if(GPIO_PORTF_RIS_R&0x10){//if PF4		SW1
		GPIO_PORTF_ICR_R = 0x10;
		//////////////////////////
	}

}
void Timer1_Init(unsigned long period){
  SYSCTL_RCGCTIMER_R |= 0x02;   // 0) activate TIMER1
  TIMER1_CTL_R = 0x00000000;    // 1) disable TIMER1A during setup
  TIMER1_CFG_R = 0x00000000;    // 2) configure for 32-bit mode
  TIMER1_TAMR_R = 0x00000002;   // 3) configure for periodic mode, default down-count settings
  TIMER1_TAILR_R = period-1;    // 4) reload value
  TIMER1_TAPR_R = 0;            // 5) bus clock resolution
  TIMER1_ICR_R = 0x00000001;    // 6) clear TIMER1A timeout flag
  TIMER1_IMR_R = 0x00000001;    // 7) arm timeout interrupt
  NVIC_PRI5_R = (NVIC_PRI5_R&0xFFFF00FF)|0x00008000; // 8) priority 4
// interrupts enabled in the main program after all devices initialized
// vector number 37, interrupt number 21
  NVIC_EN0_R = 1<<21;           // 9) enable IRQ 21 in NVIC
  TIMER1_CTL_R = 0x00000001;    // 10) enable TIMER1A
}

void Timer1A_Handler(void){
  TIMER1_ICR_R = TIMER_ICR_TATOCINT;// acknowledge TIMER1A timeout
	//squarewave();
	//sawtooth();
	//trianglewave();
	sine_wave();
	}


int main(void){
	//Button_Init();
	//LED_Init();
	PortB_Init();
	//Sine_Init();
	Timer1_Init(131);///16000000/480/256
	while(1);
}
